## 虚拟DOM的diff算法

### 什么是虚拟dom

react元素就是一个虚拟dom



小结: 

直接操作dom元素,效率远远低于操作数据(虚拟dom)

react中创建出来的元素,其实不是真实的dom元素,是虚拟dom

react如何渲染视图层: 根据之前的结构,生成一个旧的虚拟dom. 然后代码发生变化,也就意味着新的虚拟dom结构发生变化.这个时候react底层会比较这两个虚拟dom结构.然后根据比较的结构,修改真实的dom.真实dom被修改了,视图就会跟着发生变化



### 什么是diff算法

一种对比新/旧虚拟DOM树的高效算法，能快速计算哪些虚拟DOM树发生了变化，从而只更新局部DOM。

传统的 diff 算法性能开销大，无法满足大规模 DOM 操作需求。 React 通过制定大胆的策略，将性能开销降到最低。

### diff 策略

1. Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。
2. 拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。
3. 对于同一层级的一组子节点，它们可以通过唯一 id 进行区分。

基于以上三个前提策略，React 分别对 tree diff、component diff 以及 element diff 进行算法优化，事实也证明这三个前提策略是合理且准确的，它保证了整体界面构建的性能。

### tree diff

基于策略一，React 对树的算法进行了简洁明了的优化，即对树进行分层比较，两棵树只会对同一层次的节点进行比较。

既然 DOM 节点跨层级的移动操作少到可以忽略不计，针对这一现象，只会对相同颜色方框内的 DOM 节点进行比较，即同一个父节点下的所有子节点。当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。这样只需要对树进行一次遍历，便能完成整个 DOM 树的比较。

![](https://pic1.zhimg.com/80/0c08dbb6b1e0745780de4d208ad51d34_hd.png)

**问题：如果出现了 DOM 节点跨层级的移动操作，性能不好！**

![](https://pic2.zhimg.com/80/d712a73769688afe1ef1a055391d99ed_hd.png)

如上图所示：React diff 的执行情况：create A -> create B -> create C -> delete A

由此可发现，当出现节点跨层级移动时，并不会出现想象中的移动操作，而是以 A 为根节点的树被整个重新创建，这是一种影响 React 性能的操作，因此 React 官方建议不要进行 DOM 节点跨层级的操作。

> 注意：在开发组件时，保持稳定的 DOM 结构会有助于性能的提升。例如，可以通过 CSS 隐藏或显示节点，而不是真的移除或添加 DOM 节点。

### component diff 

React 是基于组件构建应用的，对于组件间的比较所采取的策略也是简洁高效。

- 如果是同一类型的组件，按照原策略继续tree diff。
- 如果不是，则将该组件判断为 dirty component，从而替换整个组件下的所有子节点。
- 对于同一类型的组件，有可能其 Virtual DOM 没有任何变化，如果能够确切的知道这点那可以节省大量的 diff 运算时间，因此 React 允许用户通过 shouldComponentUpdate() 来判断该组件是否需要进行 diff。

### element diff

如下图，老集合中包含节点：A、B、C、D，更新后的新集合中包含节点：B、A、D、C，此时新老集合进行 diff 差异化对比，发现 B != A，则创建并插入 B 至新集合，删除老集合 A；以此类推，创建并插入 A、D 和 C，删除 B、C 和 D。

![](https://pic2.zhimg.com/80/7541670c089b84c59b84e9438e92a8e9_hd.png)

React 发现这类操作繁琐冗余，因为这些都是相同的节点，但由于位置发生变化，导致需要进行繁杂低效的删除、创建操作，其实只要对这些节点进行位置移动即可。

针对这一现象，React 提出优化策略：**允许开发者对同一层级的同组子节点，添加唯一 key 进行区分，虽然只是小小的改动，性能上却发生了翻天覆地的变化！**

新老集合所包含的节点，如下图所示，新老集合进行 diff 差异化对比，通过 key 发现新老集合中的节点都是相同的节点，因此无需进行节点删除和创建，只需要将老集合中节点的位置进行移动，更新为新集合中节点的位置，此时 React 给出的 diff 结果为：B、D 不做任何操作，A、C 进行移动操作，即可。

![](https://pic4.zhimg.com/80/c0aa97d996de5e7f1069e97ca3accfeb_hd.png)

问题：如下图所示，若新集合的节点更新为：D、A、B、C，与老集合对比只有 D 节点移动，而 A、B、C 仍然保持原有的顺序，理论上 diff 应该只需对 D 执行移动操作，然而由于 D 在老集合的位置是最大的，造成 D 没有执行移动操作，而是 A、B、C 全部移动到 D 节点后面的现象。

![](https://pic1.zhimg.com/80/7b9beae0cf0a5bc8c2e82d00c43d1c90_hd.png)

> 建议：在开发过程中，尽量减少类似将最后一个节点移动到列表首部的操作，当节点数量过大或更新操作过于频繁时，在一定程度上会影响 React 的渲染性能。

### 总结

- React 通过分层求异的策略，对 tree diff 进行算法优化；
- React 通过相同类生成相似树形结构，不同类生成不同树形结构的策略，对 component diff 进行算法优化；
- React 通过设置唯一 key的策略，对 element diff 进行算法优化；
- 建议，在开发组件时，保持稳定的 DOM 结构会有助于性能的提升；
- 建议，在开发过程中，尽量减少类似将最后一个节点移动到列表首部的操作，当节点数量过大或更新操作过于频繁时，在一定程度上会影响 React 的渲染性能。